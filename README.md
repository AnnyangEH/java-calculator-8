# 문자열 덧셈 계산기

## 📘 과제 진행 요구 사항
- 미션은 **문자열 덧셈 계산기 저장소를 포크하고 클론**하는 것으로 시작한다.
- 구현 전 `README.md`에 **구현할 기능 목록을 정리**한다.
- **기능 단위로 커밋**하며, 커밋 메시지는 *AngularJS Git Commit Message Convention*을 따른다.
- 구현 완료 후 **모든 테스트가 통과하는지 확인**한다.

---

## ⚙️ 기능 요구 사항
- 입력한 문자열에서 숫자를 추출하여 더하는 계산기 구현
- 기본 구분자: 쉼표 `","` 콜론`":"`
- 커스텀 구분자: 문자열 앞부분의 `"//"`과 `"\n"` 사이의 문자
    - 예) `"//;\n1;2;3"` → 결과는 6
- 잘못된 입력값일 경우 `IllegalArgumentException` 발생
- ***빈 문자열은 공백으로 간주***

---

## 💻 프로그래밍 요구 사항
- JDK 21 사용
- 시작점은 `Application`의 `main()`
- `build.gradle` 파일 변경 x, 외부 라이브러리 사용 금지
- 프로그램 종료 시 `System.exit()` 를 호출하지 않는다
- 달리 명시하지 않는 한 파일, 패키지 등의 이름을 바꾸거나 이동하지 않는다
- 자바 코드 컨벤션을 지키면서 프로그래밍 한다
  - 기본적으로 `Java Style Guide`를 원칙으로 한다

### 라이브러리
- `camp.nextstep.edu.missionutils.Console`의 `readLine()`으로 입력 받기 
---

## 🧩 구현 기능 목록

### 입력 처리

- 입력 : 구분자와 양수로 구성된 문자열
- 출력 : 덧셈 결과
- 입력메시지 출력 후 readLine()으로 입력 받기
- 기본/커스텀 구분자 식별 및 분리
- 구분된 문자열을 정수로 변환

### 계산 처리

- 합을 계산
- 결과를 `결과 : x`을 출력

### 예외 처리
- 빈 문자열이 입력된 경우
- 음수가 입력된 경우 
- 문자가 입력된 경우 
- 커스텀 구분자에 `/`나 `\n` 이 더 많이 들어온 경우 ex) ///;\\\\\\\n1;2;3;4
- 큰 수가 더해진 경우
- 커스텀 구분자만 있는 경우
- 커스텀 구분자가 '숫자'인 경우
- 커스텀 구분자가 복수일 경우
- 커스텀 구분자의 포맷이 틀린 경우 ex) //;\12;4;;5;6
---
## 실행 예시
```
덧셈할 문자열을 입력해 주세요.
1,2,3
결과 : 6

덧셈할 문자열을 입력해 주세요.
//;\n1;2;3
결과 : 6

덧셈할 문자열을 입력해 주세요.
//;\n;;;;;;
IllegalArgumentException: 커스텀 구분자 형식 오류.
```
---
## 함수 목록

1. **run()**
  - 입력 받기 > 검증 > 구분자/숫자 분리 > 합산 > 결과 출력
2. **parseDelimiter()**
  - 기본 구분자 `[,:]` 또는 커스텀 구분자 추출
3. **parseNumbers()**
  - 정규식 `//(.)\n(.*)` 으로 숫자 부분 분리
4. **validateTokens()**
  - 빈 토큰, 음수, 숫자 외 문자 검증
5. **calculate()**
  - `BigInteger`로 합계 계산
---

## 🔍 구현 중 어려웠던 점 & 해결 과정

### 🧵 1. 개행(`\n`, `\\n`) 처리
- 입력 문자열이 실제 개행인지(`\n`) 또는 리터럴 문자열(`\\n`)인지 구분해야 했다.
- `Matcher` 정규식으로 매칭되지 않을 경우를 대비해, 직접 `indexOf('\n')` 과 `indexOf("\\n")` 둘 다 검사하도록 처리했다.
- 덕분에 **윈도우/맥/리터럴 문자열 입력 모두 안정적으로 처리**할 수 있었다.

### ⚙️ 2. split() 의 기본 동작
- `String.split()` 이 끝의 빈 토큰을 제거한다는 사실을 간과해서  
  `"1,2,3,"` 같은 입력에서 마지막 빈 값이 사라지는 문제가 발생했다.
- `split(delimiter, -1)` 로 수정하여 **모든 토큰(끝의 빈 문자열 포함)** 을 유지하도록 바꾸었고,  
  이를 통해 “구분자로 끝나는 입력”이나 “구분자만 있는 입력”도 정상적으로 예외 처리됐다.

### 🔢 3. 정규식 매칭
- 커스텀 구분자 파싱을 위해 `//(.)\r?\n(.*)` 패턴을 사용했다.
- 정규식으로 처리하지 못하는 케이스(예: `\\n` 리터럴 입력)는 별도로 문자열 연산으로 fallback 처리했다.
- 결과적으로 **명세 기반 입력뿐 아니라 비정형 입력도 안전하게 처리**할 수 있었다.

---

## 🧠 회고

- 단순한 덧셈 계산보다 **문자열 파싱 로직의 복잡성**을 깊게 이해할 수 있었다.
- `split()`의 기본 동작을 직접 디버깅하며, 자바 문자열 API의 세부적인 차이를 체감했다.
- 정규식 패턴이 모든 상황을 해결하지 못한다는 점에서,  
  **정규식 + 문자열 인덱스 조합 설계**의 중요성을 배웠다.
- 이번 과정을 통해 예외 상황을 **논리적으로 분리하고, 테스트 가능한 형태로 만들기**의 가치를 배웠다.

---